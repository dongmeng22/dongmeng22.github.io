import{_ as c,a as n}from"./chunks/Contributors.vue_vue_type_script_setup_true_lang.2d10c1d4.js";import{_ as s}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.63457685.js";import{_ as t,o as d,c as r,D as e,x as l,a as p,Q as h}from"./chunks/framework.c7127555.js";import"./chunks/commonjsHelpers.725317a4.js";const A=JSON.parse('{"title":"在浏览器里，从输入 URL 到页面展示，这中间发生了什么？","description":"","frontmatter":{},"headers":[{"level":2,"title":"总览","slug":"总览","link":"#总览","children":[]},{"level":2,"title":"用户输入","slug":"用户输入","link":"#用户输入","children":[]},{"level":2,"title":"URL 请求","slug":"url-请求","link":"#url-请求","children":[]},{"level":2,"title":"重定向","slug":"重定向","link":"#重定向","children":[]},{"level":2,"title":"响应数据类型处理","slug":"响应数据类型处理","link":"#响应数据类型处理","children":[]},{"level":2,"title":"准备渲染进程","slug":"准备渲染进程","link":"#准备渲染进程","children":[]},{"level":2,"title":"提交文档","slug":"提交文档","link":"#提交文档","children":[]},{"level":2,"title":"Contributors","slug":"contributors","link":"#contributors","children":[]}],"relativePath":"basics/browser/02从url到页面呈现.md","lastUpdated":1678883566000}'),u={name:"basics/browser/02从url到页面呈现.md"},_=l("h1",{id:"在浏览器里-从输入-url-到页面展示-这中间发生了什么",tabindex:"-1"},[p("在浏览器里，从输入 URL 到页面展示，这中间发生了什么？ "),l("a",{class:"header-anchor",href:"#在浏览器里-从输入-url-到页面展示-这中间发生了什么","aria-hidden":"true"},"#")],-1),b=h(`<p>详细探索一下这道经典的面试题，主要考察以下两个方面的知识点：</p><ol><li>网络知识（HTTP、TCP、CDN）</li><li>浏览器知识（缓存、渲染原理）</li></ol><h2 id="总览" tabindex="-1">总览 <a class="header-anchor" href="#总览" aria-hidden="true">#</a></h2><ul><li><code>浏览器进程</code>主要负责用户交互、子进程管理和文件储存等功能。</li><li><code>网络进程</code>是面向渲染进程和浏览器进程等提供网络下载功能。</li><li><code>渲染进程</code>的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。</li></ul><p>从URL到页面显示大体流程如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c29dfda4854c46c78f107c2431d3e0f7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ol><li><code>浏览器进程</code>接收到用户输入的URL请求，将该URL请求转发给<code>网络进程</code></li><li>在<code>网络进程</code>中发起URL相应的请求</li><li><code>网络进程</code>接收到了响应头数据，便解析响应头数据，并将数据转发给<code>浏览器进程</code></li><li><code>浏览器进程</code>接收到网络进程的响应头数据之后，发送“提交导航(CommitNavigation)”消息到<code>渲染进程</code></li><li><code>渲染进程</code>接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和<code>网络进程</code>建立数据管道</li><li><code>渲染进程</code>会向浏览器进程“确认提交”，这是告诉<code>浏览器进程</code>：“已经准备好接受和解析页面数据了”</li><li><code>浏览器进程</code>接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态</li></ol><h2 id="用户输入" tabindex="-1">用户输入 <a class="header-anchor" href="#用户输入" aria-hidden="true">#</a></h2><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL</li><li>如果判断输入内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL</li></ul><p>当前页面即将要被替换成新的页面，不过在这个流程继续之前，当前页面还可以执行一次 <code>beforeunload</code> 事件，该事件允许页面在退出之前执行一些数据清理操作，也可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再执行任何后续工作。</p><p>当前页面没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程。浏览器标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新的页面。因为需要等待<strong>提交文档</strong>阶段，页面内容才会被替换。</p><h2 id="url-请求" tabindex="-1">URL 请求 <a class="header-anchor" href="#url-请求" aria-hidden="true">#</a></h2><p><code>浏览器进程</code>通过IPC将URL请求发送到<code>网络进程</code>，由<code>网络进程</code>发起URL请求流程，请求页面资源。</p><ol><li>【<code>查缓存</code>】首先网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程</li><li>【<code>域名解析</code>】请求前第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。</li><li>【<code>建立TLS连接</code>】如果请求协议是 HTTPS，那么还需要建立 TLS 连接</li><li>【<code>建立TCP连接</code>】利用 IP 地址和服务器建立 TCP 连接</li><li>【<code>构建请求信息</code>】连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息</li><li>【<code>服务端返回响应</code>】服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程</li><li>【<code>解析响应</code>】等网络进程接收了响应行和响应头之后，就开始解析响应报文的内容了</li></ol><h2 id="重定向" tabindex="-1">重定向 <a class="header-anchor" href="#重定向" aria-hidden="true">#</a></h2><p>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p><h2 id="响应数据类型处理" tabindex="-1">响应数据类型处理 <a class="header-anchor" href="#响应数据类型处理" aria-hidden="true">#</a></h2><p>通过Content-Type响应头信息来判断请求的数据类型。浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p><p>如果响应头中的 Content-type 字段的值是 <code>text/html</code>，这就是告诉浏览器，服务器返回的数据是 HTML 格式。浏览器则会继续进行导航流程，准备渲染进程。</p><p>如果 Content-Type 的值是 <code>application/octet-stream</code>，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。</p><h2 id="准备渲染进程" tabindex="-1">准备渲染进程 <a class="header-anchor" href="#准备渲染进程" aria-hidden="true">#</a></h2><p>同一站点（same-site）定义为根域名（例如，geekbang.org）加上协议（例如，https://），还包含了该根域名下的所有子域名和不同的端口</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">https://time.geekbang.org</span></span>
<span class="line"><span style="color:#A6ACCD;">https://www.geekbang.org</span></span>
<span class="line"><span style="color:#A6ACCD;">https://www.geekbang.org:8080</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程；</li><li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><h2 id="提交文档" tabindex="-1">提交文档 <a class="header-anchor" href="#提交文档" aria-hidden="true">#</a></h2><p>提交文档是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p><ol><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li><li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li><li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ol><p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，就到了渲染阶段进行页面渲染。而一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-hidden="true">#</a></h2>`,33);function m(g,f,C,T,L,k){const a=s,i=c,o=n;return d(),r("div",null,[_,e(a,{readTime:"6",words:"2.1k"}),b,e(i),e(o)])}const y=t(u,[["render",m]]);export{A as __pageData,y as default};
