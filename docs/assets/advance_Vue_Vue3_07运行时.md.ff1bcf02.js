import{_ as a,a as s}from"./chunks/Contributors.vue_vue_type_script_setup_true_lang.3dcd3b9e.js";import{_ as p}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.358bd1c3.js";import{_ as c,o as i,c as _,D as e,x as t,a as d,Q as u}from"./chunks/framework.c7127555.js";import"./chunks/commonjsHelpers.725317a4.js";const N=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"首次渲染","slug":"首次渲染","link":"#首次渲染","children":[]},{"level":2,"title":"Contributors","slug":"contributors","link":"#contributors","children":[]}],"relativePath":"advance/Vue/Vue3/07运行时.md","lastUpdated":null}'),m={name:"advance/Vue/Vue3/07运行时.md"},l=t("p",null,"前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。",-1),h=t("h2",{id:"首次渲染",tabindex:"-1"},[d("首次渲染 "),t("a",{class:"header-anchor",href:"#首次渲染","aria-hidden":"true"},"#")],-1),V=u('<p>我们知道，想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染，代码逻辑如下：</p><p>所以 createApp 就是项目的初始化渲染入口。</p><p>但是这段简单的代码是怎么完成初始化渲染的呢？我们可以在 Vue 中的 runtime-dom 中看到 createApp 的定义，你可以打开 GitHub 链接查看。</p><p>这里就有一个看代码的小技巧，分享给你，我们首次查看源码的时候，可以先把一些无用的信息删除，方便自己梳理主体的逻辑。看 Vue 代码，和今天主题无关的无用信息有哪些，<strong>COMPAT</strong> 代码是用来兼容 Vue 2 的，<strong>DEV</strong> 代码是用来调试的，我们可以把这些代码删除之后，得到下面的简化版 createApp 源码。</p><p>再看思路就比较清晰了。我们使用 ensureRenderer 返回的对象去创建 app，并且重写了 app.mount 方法；在 mount 方法内部，我们查找 mount 传递的 DOM 元素，并且调用 ensureRenderer 返回的 mount 方法，进行初始化渲染。如下图所示：</p><p>之前我们讲过要会 TypeScript，这时你就能感受到 TypeScript 的好处了，现在即使我们不知道 app.mount 是什么逻辑，也能知道这个函数的参数只能是 Element、ShadowRoot 或者 string 三者之一，也就很好理解内部的 normalizeContainer 就是把你传递的参数统一变为浏览器的 DOM 元素，Typescript 类型带来的好处，我们在读源码的时候会一直感受得到。</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-hidden="true">#</a></h2>',7);function f(T,A,b,g,C,S){const r=p,o=a,n=s;return i(),_("div",null,[l,h,e(r,{readTime:"1",words:"485"}),V,e(o),e(n)])}const P=c(m,[["render",f]]);export{N as __pageData,P as default};
